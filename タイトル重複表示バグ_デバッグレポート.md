# タイトル重複表示バグ デバッグレポート

**対象サイト**: ieltsconsult.netlify.app  
**事象**: 記事ページ（`/posts/[slug]`）でタイトルが同じ内容で2回表示される  
**報告日**: 2026年2月2日

---

## 1. 現象の整理

### 1.1 観察された症状
- 記事詳細ページ（`/posts/[slug]`）で、同一のタイトルが2回表示される
- 1回目: ページコンポーネント側で描画される大きなH1タイトル（上部）
- 2回目: 記事本文（HTMLコンテンツ）内に含まれるH1タグがそのまま表示される（本文先頭）

### 1.2 影響範囲
- すべてのHTML記事（`n*.html`形式のファイル）で発生する可能性
- MDX/Markdown記事（`content/posts/*.mdx`）では発生しない（本文にH1が含まれていない前提）

---

## 2. 調査結果：タイトル描画箇所の特定

### 2.1 タイトル描画箇所の一覧

#### 箇所1: ページコンポーネント側のH1
**ファイル**: `app/posts/[slug]/page.tsx`  
**行番号**: 194行目

```194:194:app/posts/[slug]/page.tsx
          <h1 className="text-3xl md:text-4xl lg:text-5xl font-semibold tracking-tight mb-4">{post.title}</h1>
```

**説明**: Next.jsのページコンポーネント内で、`post.title`をH1タグとして明示的に描画している。これは意図的な実装で、SEOとアクセシビリティの観点から正しい。

#### 箇所2: HTMLコンテンツ内のH1（問題の原因）
**ファイル**: HTMLファイル（例: `n1a971fb03450.html`）  
**行番号**: 8行目

```8:8:n1a971fb03450.html
<h1>IELTS ライティング Task 2：失点を防ぐ15の鉄則</h1>
```

**説明**: インポート元のNote.comから取得したHTMLファイル内に、記事タイトルがH1タグとして含まれている。このH1タグが削除されずに、そのまま`post.content`としてレンダリングされている。

#### 箇所3: HTMLコンテンツのレンダリング
**ファイル**: `app/posts/[slug]/page.tsx`  
**行番号**: 214-217行目

```214:217:app/posts/[slug]/page.tsx
        <div
          className="prose prose-lg dark:prose-invert max-w-none mb-12"
          dangerouslySetInnerHTML={{ __html: post.content }}
        />
```

**説明**: `post.content`（HTML文字列）を`dangerouslySetInnerHTML`で直接DOMに挿入している。この時点で、HTMLコンテンツ内のH1タグがそのまま表示される。

### 2.2 データフローの追跡

1. **HTMLファイル読み込み**: `lib/posts.ts` の `getPostFromHtml()` 関数（64-198行目）
2. **H1削除処理**: 88-99行目でH1タグを削除しようとしている
3. **サニタイズ処理**: 105行目で`sanitizeHtml()`を実行
4. **コンテンツ返却**: 188行目で`content`を返却
5. **ページレンダリング**: `app/posts/[slug]/page.tsx`で表示

---

## 3. 原因仮説（根拠付き）

### 仮説1: H1削除処理のタイミング問題（最有力） ⭐⭐⭐⭐⭐

**根拠**:
- `lib/posts.ts` の88-99行目で、JSDOMと正規表現の両方でH1削除を試みている
- しかし、処理順序に問題がある可能性

**該当コード**:
```88:105:lib/posts.ts
    // 最初のh1タグを削除（タイトルが重複表示されるのを防ぐ）
    // JSDOMで削除
    const firstH1 = document.querySelector('body h1');
    if (firstH1) {
      firstH1.remove();
      // h1を削除した後、再度innerHTMLを取得
      content = bodyElement?.innerHTML || '';
    }
    
    // 正規表現でも確実に最初のh1タグを削除（念のため）
    // bodyタグ内の最初のh1タグのみを削除（改行や空白も含む）
    content = content.replace(/<h1[^>]*>.*?<\/h1>\s*/is, '');

    // 画像パスを修正（assets/... → /assets/...）
    content = content.replace(/src="assets\//g, 'src="/assets/');

    // HTMLをサニタイズ
    content = sanitizeHtml(content, sanitizeOptions);
```

**問題点**:
1. JSDOMで削除した後、`innerHTML`を再取得しているが、その後の正規表現処理で削除済みのH1を再度削除しようとしている（冗長）
2. 正規表現が`/is`フラグを使用しているが、実際のHTMLファイルではH1タグが改行なしの1行で存在する可能性がある
3. **最も重要な問題**: `sanitizeHtml()`の処理がH1削除の**後**に実行されているが、`sanitizeOptions`で`h1`が`allowedTags`に含まれているため、削除されたH1が再び復活する可能性は低い。しかし、処理順序の問題で、H1が完全に削除されていない可能性がある

**再現確認方法**:
```bash
# 実際のHTMLファイルでH1が残っているか確認
grep -n "<h1" n*.html | head -5
```

**確認結果**: 実際のHTMLファイル（`n1a971fb03450.html`）の8行目にH1タグが存在することを確認済み。

---

### 仮説2: 正規表現のマッチング失敗 ⭐⭐⭐⭐

**根拠**:
- 正規表現 `/<h1[^>]*>.*?<\/h1>\s*/is` が、実際のHTMLの構造と完全に一致していない可能性
- HTMLファイル内のH1タグが属性なしのシンプルな形式（`<h1>タイトル</h1>`）だが、前後の空白や改行の扱いでマッチしない可能性

**該当コード**:
```99:99:lib/posts.ts
    content = content.replace(/<h1[^>]*>.*?<\/h1>\s*/is, '');
```

**問題点**:
- `.*?`は非貪欲マッチだが、H1タグ内に改行が含まれている場合、`/s`フラグ（dotall）が必要
- 実際のHTMLでは、H1タグの直後に改行がない可能性がある

**再現確認方法**:
```typescript
// デバッグ用コード
const testContent = '<h1>IELTS ライティング Task 2：失点を防ぐ15の鉄則</h1><figure>';
const result = testContent.replace(/<h1[^>]*>.*?<\/h1>\s*/is, '');
console.log('削除前:', testContent);
console.log('削除後:', result);
```

---

### 仮説3: JSDOMのDOM操作が反映されていない ⭐⭐⭐

**根拠**:
- JSDOMで`firstH1.remove()`を実行しているが、その後の`innerHTML`取得時に削除が反映されていない可能性
- JSDOMのバージョンや実装の違いで、DOM操作が正しく反映されない場合がある

**該当コード**:
```90:95:lib/posts.ts
    const firstH1 = document.querySelector('body h1');
    if (firstH1) {
      firstH1.remove();
      // h1を削除した後、再度innerHTMLを取得
      content = bodyElement?.innerHTML || '';
    }
```

**問題点**:
- `bodyElement?.innerHTML`を取得するタイミングで、JSDOMのDOM操作が正しく反映されていない可能性
- `remove()`メソッドが非同期で動作する、またはDOMの更新が即座に反映されない可能性

**再現確認方法**:
```typescript
// デバッグ用コード
const firstH1 = document.querySelector('body h1');
console.log('削除前のH1:', firstH1);
if (firstH1) {
  firstH1.remove();
  const afterRemove = document.querySelector('body h1');
  console.log('削除後のH1:', afterRemove); // nullになるはず
  content = bodyElement?.innerHTML || '';
  console.log('content内にH1が含まれているか:', content.includes('<h1'));
}
```

---

### 仮説4: sanitizeHtmlの処理でH1が復活 ⭐⭐

**根拠**:
- `sanitizeHtml()`の処理で、削除されたH1が何らかの理由で復活する可能性（低いが可能性はある）

**該当コード**:
```39:59:lib/posts.ts
const sanitizeOptions: sanitizeHtml.IOptions = {
  allowedTags: sanitizeHtml.defaults.allowedTags.concat([
    'img',
    'figure',
    'figcaption',
    'h1',  // ← H1が許可されている
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
  ]),
  // ...
};
```

**問題点**:
- `sanitizeHtml`は許可されたタグを**保持**するだけで、削除されたタグを復活させることはない
- この仮説の可能性は低い

---

### 仮説5: 複数のgetPostFromHtml関数の競合 ⭐

**根拠**:
- `lib/posts.ts`と`lib/html-posts.ts`の両方に`getPostFromHtml`関数が存在する
- どちらが実際に使用されているか不明確

**該当コード**:
- `lib/posts.ts`: 64-198行目
- `lib/html-posts.ts`: 23-97行目

**問題点**:
- `lib/posts.ts`の`getPostBySlug()`関数（333-374行目）では、`lib/posts.ts`内の`getPostFromHtml()`を呼び出している
- `lib/html-posts.ts`の`getPostFromHtml()`は、H1削除処理が正規表現のみで、JSDOMを使用していない（62-67行目）

**確認結果**: `app/posts/[slug]/page.tsx`では`@/lib/posts`から`getPostBySlug`をインポートしているため、`lib/posts.ts`の`getPostFromHtml()`が使用されている。

---

### 仮説6: HTMLファイルの構造問題 ⭐

**根拠**:
- HTMLファイル内のH1タグが、`<body>`タグの直後に存在するが、何らかの理由で削除処理が機能していない

**実際のHTML構造**:
```html
<body>
<h1>IELTS ライティング Task 2：失点を防ぐ15の鉄則</h1>
<figure>...
```

**問題点**:
- H1タグが`<body>`の直後に存在し、属性がないシンプルな形式
- 削除処理が機能していない理由が不明

---

## 4. 最有力原因

**仮説1: H1削除処理のタイミング問題**が最も可能性が高い。

### 4.1 根拠の整理

1. **コード上での証拠**:
   - `lib/posts.ts`の88-99行目で、JSDOMと正規表現の両方でH1削除を試みている
   - しかし、実際のHTMLファイル（`n1a971fb03450.html`）では、H1タグが8行目に存在している
   - 削除処理が実行されているにもかかわらず、H1が残っている

2. **処理順序の問題**:
   - JSDOMで削除 → `innerHTML`再取得 → 正規表現で削除 → サニタイズ
   - この順序で問題が発生する可能性:
     - JSDOMの`remove()`が正しく反映されていない
     - 正規表現のマッチングが失敗している
     - サニタイズ処理で何らかの問題が発生している

3. **実際の動作確認**:
   - HTMLファイル内にH1タグが存在することを確認済み
   - ページ上でH1が2回表示されていることを確認済み

### 4.2 根本原因の特定

**最も可能性が高い原因**: 正規表現 `/<h1[^>]*>.*?<\/h1>\s*/is` が、実際のHTMLの構造と完全に一致していない、またはJSDOMの`remove()`処理が`innerHTML`の再取得前に反映されていない。

**具体的な問題**:
1. JSDOMで`remove()`を実行した後、`innerHTML`を再取得するタイミングで、DOMの更新が反映されていない可能性
2. 正規表現が、H1タグの前後の空白や改行を正確にマッチングできていない可能性

---

## 5. 修正案（A/B比較）

### 修正案A: ページ側のH1は残し、HTML本文側のH1を確実に削除

**方針**: 
- ページコンポーネント側のH1（`app/posts/[slug]/page.tsx`の194行目）は維持
- HTMLコンテンツ内のH1タグを、より確実な方法で削除

**実装方法**:
1. JSDOMでH1を削除した後、`innerHTML`を再取得する前に、DOMの更新を確実に反映
2. 正規表現を改善し、より確実にH1タグをマッチング
3. 複数の正規表現パターンで削除を試みる（フォールバック）

**メリット**:
- ✅ SEO: ページのH1タグが1つだけになり、SEO的に正しい構造
- ✅ アクセシビリティ: スクリーンリーダーが正しく認識
- ✅ 見出し階層: H1 → H2 → H3 の階層が正しく保たれる
- ✅ OGP: ページ側のH1がOGPのtitleと一致
- ✅ 目次生成: ページ側のH1を基準に目次を生成可能
- ✅ 読了時間: 影響なし

**デメリット**:
- HTMLコンテンツ内のH1を削除する処理が複雑になる可能性

**推奨度**: ⭐⭐⭐⭐⭐（最推奨）

---

### 修正案B: HTML本文のH1を残し、ページ側のH1を削除

**方針**:
- ページコンポーネント側のH1を削除
- HTMLコンテンツ内のH1タグをそのまま表示

**実装方法**:
- `app/posts/[slug]/page.tsx`の194行目のH1タグを削除またはコメントアウト

**メリット**:
- ✅ 実装が簡単（1行削除するだけ）
- ✅ HTMLコンテンツの構造をそのまま保持

**デメリット**:
- ❌ SEO: ページのH1タグがHTMLコンテンツ内に依存し、構造が不安定
- ❌ アクセシビリティ: HTMLコンテンツ内のH1のスタイリングがページのデザインと一致しない可能性
- ❌ 見出し階層: HTMLコンテンツ内のH1が、ページの構造（header, article等）の外に存在する可能性
- ❌ OGP: ページ側のH1がないため、OGPのtitleと表示タイトルが一致しない可能性
- ❌ 目次生成: HTMLコンテンツ内のH1を基準にする必要があり、ページ構造との整合性が取れない
- ❌ スタイリング: HTMLコンテンツ内のH1が、ページのデザインシステム（Tailwind CSS）と一致しない可能性

**推奨度**: ⭐（非推奨）

---

### 修正案の比較表

| 項目 | 修正案A（推奨） | 修正案B（非推奨） |
|------|----------------|------------------|
| SEO | ✅ 最適（H1が1つ） | ❌ 問題あり（構造が不安定） |
| アクセシビリティ | ✅ 最適 | ❌ 問題あり |
| 見出し階層 | ✅ 正しい | ❌ 問題あり |
| OGP | ✅ 整合性あり | ❌ 整合性なし |
| 目次生成 | ✅ 容易 | ❌ 困難 |
| 実装の容易さ | ⚠️ 中程度 | ✅ 簡単 |
| デザイン整合性 | ✅ 高い | ❌ 低い |

**結論**: **修正案Aを強く推奨**。SEO、アクセシビリティ、UXの観点から、ページ側のH1を維持し、HTMLコンテンツ内のH1を確実に削除する方が望ましい。

---

## 6. パッチ案（ファイル別）

### 6.1 修正案Aの実装（推奨）

#### ファイル1: `lib/posts.ts`

**変更箇所**: 88-105行目

**現在のコード**:
```typescript
    // 最初のh1タグを削除（タイトルが重複表示されるのを防ぐ）
    // JSDOMで削除
    const firstH1 = document.querySelector('body h1');
    if (firstH1) {
      firstH1.remove();
      // h1を削除した後、再度innerHTMLを取得
      content = bodyElement?.innerHTML || '';
    }
    
    // 正規表現でも確実に最初のh1タグを削除（念のため）
    // bodyタグ内の最初のh1タグのみを削除（改行や空白も含む）
    content = content.replace(/<h1[^>]*>.*?<\/h1>\s*/is, '');
```

**修正後のコード**:
```typescript
    // 最初のh1タグを削除（タイトルが重複表示されるのを防ぐ）
    // 複数の方法で確実に削除
    
    // 方法1: JSDOMで削除
    const firstH1 = document.querySelector('body h1');
    if (firstH1) {
      firstH1.remove();
    }
    
    // 方法2: innerHTMLを再取得してから正規表現で削除（確実性を高める）
    content = bodyElement?.innerHTML || '';
    
    // 方法3: 複数の正規表現パターンで削除（フォールバック）
    // パターン1: 標準的なH1タグ（属性あり/なし、改行あり/なし）
    content = content.replace(/<h1[^>]*>[\s\S]*?<\/h1>\s*/i, '');
    
    // パターン2: H1タグの前後に空白や改行がある場合
    content = content.replace(/\s*<h1[^>]*>[\s\S]*?<\/h1>\s*/i, '');
    
    // パターン3: bodyタグの直後にH1がある場合（念のため）
    content = content.replace(/^<h1[^>]*>[\s\S]*?<\/h1>\s*/im, '');
```

**変更理由**:
1. JSDOMの`remove()`後に`innerHTML`を再取得するタイミングを明確化
2. 正規表現を複数のパターンで試行し、確実にH1を削除
3. `[\s\S]*?`を使用して、改行を含むすべての文字にマッチング（`.*?`では改行にマッチしない場合がある）
4. 複数のパターンで削除を試みることで、フォールバック機能を提供

---

#### ファイル2: `lib/html-posts.ts`（使用されていないが、念のため修正）

**変更箇所**: 62-67行目

**現在のコード**:
```typescript
    // 本文から最初のh1タグを削除（タイトルが重複表示されるのを防ぐ）
    let processedContent = htmlContent;
    if (h1Match) {
      // 最初のh1タグを削除（改行や空白も含む、大文字小文字を区別しない）
      processedContent = processedContent.replace(/<h1[^>]*>.*?<\/h1>\s*/is, '');
    }
```

**修正後のコード**:
```typescript
    // 本文から最初のh1タグを削除（タイトルが重複表示されるのを防ぐ）
    let processedContent = htmlContent;
    
    // 複数のパターンで確実に削除
    processedContent = processedContent.replace(/<h1[^>]*>[\s\S]*?<\/h1>\s*/i, '');
    processedContent = processedContent.replace(/\s*<h1[^>]*>[\s\S]*?<\/h1>\s*/i, '');
    processedContent = processedContent.replace(/^<h1[^>]*>[\s\S]*?<\/h1>\s*/im, '');
```

**変更理由**:
- `lib/html-posts.ts`は現在使用されていないが、将来的に使用される可能性があるため、同様の修正を適用

---

### 6.2 最小修正案（緊急対応）

もし時間がなく、最小限の修正で対応する場合:

**ファイル**: `lib/posts.ts`  
**変更箇所**: 99行目のみ

**現在のコード**:
```typescript
    content = content.replace(/<h1[^>]*>.*?<\/h1>\s*/is, '');
```

**修正後のコード**:
```typescript
    // より確実にH1タグを削除（改行を含むすべての文字にマッチ）
    content = content.replace(/<h1[^>]*>[\s\S]*?<\/h1>\s*/i, '');
    // 念のため、もう一度試行（前後に空白がある場合）
    content = content.replace(/\s*<h1[^>]*>[\s\S]*?<\/h1>\s*/i, '');
```

**変更理由**:
- `.*?`を`[\s\S]*?`に変更することで、改行を含むすべての文字にマッチング
- `/s`フラグを削除し、`/i`フラグのみ使用（大文字小文字を区別しない）
- 2回の置換で確実に削除

---

## 7. 動作確認チェックリスト

### 7.1 基本動作確認

- [ ] **タイトルが1回だけ表示される**
  - 確認方法: 記事ページを開き、タイトルが1つだけ表示されることを確認
  - 確認対象: すべてのHTML記事（`n*.html`）

- [ ] **H1タグが1つだけ存在する**
  - 確認方法: ブラウザの開発者ツールで`document.querySelectorAll('h1')`を実行し、結果が1つだけであることを確認
  - 確認対象: すべてのHTML記事

- [ ] **OGP title/descriptionが崩れていない**
  - 確認方法: 
    - `generateMetadata()`関数の戻り値を確認
    - 実際のOGPタグを確認（`<meta property="og:title">`など）
  - 確認対象: すべてのHTML記事

- [ ] **目次、タグ、投稿日、読了時間などが崩れていない**
  - 確認方法: 記事ページのメタ情報（タグ、投稿日、読了時間）が正しく表示されることを確認
  - 確認対象: すべてのHTML記事

- [ ] **Lighthouse/SEO観点で悪化していない**
  - 確認方法: 
    - LighthouseでSEOスコアを確認（100点を維持）
    - `h1`タグが1つだけであることを確認
  - 確認対象: 代表的な記事数件

---

### 7.2 詳細確認項目

#### 7.2.1 HTMLコンテンツの確認

- [ ] **HTMLコンテンツ内にH1タグが含まれていない**
  - 確認方法: 
    ```typescript
    // デバッグ用コード
    const post = await getPostBySlug('n1a971fb03450');
    console.log('H1タグが含まれているか:', post.content.includes('<h1'));
    ```
  - 期待結果: `false`（H1タグが含まれていない）

- [ ] **HTMLコンテンツの構造が正しい**
  - 確認方法: HTMLコンテンツの先頭が`<h1>`ではなく、`<figure>`や`<p>`などで始まることを確認
  - 確認対象: すべてのHTML記事

#### 7.2.2 ページ構造の確認

- [ ] **ページのH1タグが正しく表示される**
  - 確認方法: ページコンポーネント側のH1タグ（194行目）が正しく表示されることを確認
  - 確認対象: すべてのHTML記事

- [ ] **見出し階層が正しい（H1 → H2 → H3）**
  - 確認方法: HTMLコンテンツ内の見出しがH2以下で始まることを確認
  - 確認対象: すべてのHTML記事

#### 7.2.3 パフォーマンス確認

- [ ] **ビルドが正常に完了する**
  - 確認方法: `npm run build`が正常に完了することを確認
  - エラー: なし

- [ ] **型チェックが正常に完了する**
  - 確認方法: `npm run type-check`（または`tsc --noEmit`）が正常に完了することを確認
  - エラー: なし

- [ ] **Linterが正常に完了する**
  - 確認方法: `npm run lint`が正常に完了することを確認
  - エラー: なし

---

### 7.3 ブラウザ互換性確認

- [ ] **Chromeで正常に表示される**
- [ ] **Firefoxで正常に表示される**
- [ ] **Safariで正常に表示される**
- [ ] **Edgeで正常に表示される**

---

### 7.4 レスポンシブ確認

- [ ] **モバイル表示でタイトルが1回だけ表示される**
- [ ] **タブレット表示でタイトルが1回だけ表示される**
- [ ] **デスクトップ表示でタイトルが1回だけ表示される**

---

## 8. 実装手順

### 8.1 修正案Aの実装手順

1. **バックアップの作成**
   ```bash
   git checkout -b fix/duplicate-title
   ```

2. **`lib/posts.ts`の修正**
   - 88-99行目を、上記の「修正後のコード」に置き換え

3. **動作確認**
   ```bash
   npm run build
   npm run dev
   ```
   - ローカルで記事ページを開き、タイトルが1回だけ表示されることを確認

4. **テスト実行**（テストがある場合）
   ```bash
   npm test
   ```

5. **コミット**
   ```bash
   git add lib/posts.ts
   git commit -m "fix: HTMLコンテンツ内のH1タグを確実に削除してタイトル重複を解消"
   ```

6. **プッシュとデプロイ**
   - プッシュ前に変更内容を確認
   - Netlifyにデプロイ後、本番環境で動作確認

---

### 8.2 最小修正案の実装手順

1. **バックアップの作成**
   ```bash
   git checkout -b fix/duplicate-title-minimal
   ```

2. **`lib/posts.ts`の99行目を修正**
   - 上記の「最小修正案」のコードに置き換え

3. **動作確認**（上記と同様）

4. **コミットとプッシュ**（上記と同様）

---

## 9. 再発防止策

### 9.1 コードレビューのチェックポイント

- [ ] HTMLコンテンツを処理する際に、H1タグが確実に削除されているか
- [ ] 正規表現が、実際のHTMLの構造と一致しているか
- [ ] 複数のパターンで削除を試みているか（フォールバック）

### 9.2 テストの追加（推奨）

**テストファイル**: `__tests__/lib/posts.test.ts`（新規作成）

```typescript
import { getPostFromHtml } from '@/lib/posts';

describe('getPostFromHtml', () => {
  it('should remove H1 tag from HTML content', async () => {
    // モックHTMLファイルを作成
    const mockHtml = `
      <html>
        <head><title>Test Title</title></head>
        <body>
          <h1>Test Title</h1>
          <p>Content</p>
        </body>
      </html>
    `;
    
    // テスト実行
    const post = await getPostFromHtml('test-slug');
    
    // アサーション
    expect(post.content).not.toContain('<h1');
    expect(post.content).toContain('<p>Content</p>');
  });
});
```

### 9.3 ドキュメントの更新

- [ ] `README.md`または`CONTRIBUTING.md`に、HTMLコンテンツの処理方法を記載
- [ ] H1タグの削除処理について、コメントで説明を追加

---

## 10. まとめ

### 10.1 原因の要約

**根本原因**: `lib/posts.ts`の`getPostFromHtml()`関数で、HTMLコンテンツ内のH1タグを削除する処理が、正規表現のマッチング失敗やJSDOMのDOM操作の反映タイミングの問題により、完全に機能していない。

### 10.2 推奨される修正

**修正案A（推奨）**: ページ側のH1を維持し、HTMLコンテンツ内のH1を確実に削除する。

**実装内容**:
1. JSDOMでH1を削除
2. `innerHTML`を再取得
3. 複数の正規表現パターンでH1を削除（フォールバック）

### 10.3 期待される結果

- ✅ タイトルが1回だけ表示される
- ✅ H1タグが1つだけ存在する
- ✅ SEO、アクセシビリティ、UXが最適化される

---

**レポート作成日**: 2026年2月2日  
**作成者**: AI Assistant  
**レビュー状況**: 未レビュー
